2018/1/26

1. 配置shiro的过滤链时一定要写全路径：
例：
/login.action = anon
/logout.action = logout

注：退出可以采用以上的方式，也可以交给struts2的action，在
方法里面调用subject.logout(); 是一样的效果.

2. 
	1) 被shiro权限验证拦截器perms拦截的请求会进入自定义realm的doGetAuthorizationInfo
方法里
	2) 也可以这么配：
		（1） 在Spring配置文件里面开启cglib动态代理
			<!-- 1.开启cglib动态代理 -->
  			<aop:config proxy-target-class="true"></aop:config>
		（2） 开启shiro的授权顾问
			<!-- 2.开启shiro的授权代理 -->
			<bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor">
				<property name="securityManager" ref="securityManager" />
			</bean>
		（3） 在对应的action方法头部加上注解：
			@RequiresPermissions("dict:query")
			public String getDictListPage() {
				if (StringUtils.isEmpty(type)) {
					type = null;
				}
				if (StringUtils.isEmpty(description)) {
				......
	然后该请求就同样可以进入自定义realm的doGetAuthorizationInfo方法里

3. 使用shiro的标签，在前台也对请求加以控制
<%@ taglib prefix="shiro" uri="http://shiro.apache.org/tags" %>

像下面这样把需要权限的按钮包起来：
<shiro:hasPermission name="[dict:query]">
	<input id="btnSubmit" class="btn btn-primary" type="button" onclick="dictMgr.getDictListPage(1, 10);" value="查询"/>
</shiro:hasPermission>

4. 使用shiro的加密功能：
	1）在realm里面注入凭证匹配器
	<!-- 自定义的realm -->
	<bean id="userRealm" class="com.lyu.drp.security.UserRealm">
		<!-- 注入凭证匹配器 -->
		<property name="credentialsMatcher" ref="credentialsMatcher"></property>
	</bean>
	
	<!-- 注册凭证匹配器 -->
	<bean id="credentialsMatcher" class="org.apache.shiro.authc.credential.HashedCredentialsMatcher">
		<property name="hashAlgorithmName" value="SHA-1" />
		<property name="hashIterations" value="1024" />
	</bean>

shiro的SimpleAuthenticationInfo的一个构造器如下：
包括身份信息，加密后的凭证信息，加密用到的盐，当前的realm
public SimpleAuthenticationInfo(Object principal, Object hashedCredentials, ByteSource credentialsSalt, String realmName) {
	this.principals = new SimplePrincipalCollection(principal, realmName);
	this.credentials = hashedCredentials;
	this.credentialsSalt = credentialsSalt;
}




